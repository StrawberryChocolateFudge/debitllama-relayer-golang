package eth

import (
	"reflect"
	"testing"
)

func TestParseProof(t *testing.T) {
	strProof := `{"pi_a":["21799165046751466044741854791050612873576233360455520117731076644695933073121","237857322216070326038939055851122466647816876891436053757510012155498138055","1"],"pi_b":[["8039359843367091011417471503693823059611953364550795770136412617762570717893","20362901353774374429136975997971776017368444706113308359030103452844198886346"],["9380799065296203957622237045504323238444864906244709911476053545378223821591","15835626974966355394858479666599410188851399767401275315818708596794329405031"],["1","0"]],"pi_c":["4044956268116702752876097991134769141268945862619734431496009981617907607919","13906055398350259644927757594138716667642003272757689364098168942359273563277","1"],"protocol":"groth16","curve":"bn128"}`
	got, err := ParseProof(strProof)
	if err != nil {
		t.Error("Unable to parse :", err)
	}

	pi_a := [3]string{"21799165046751466044741854791050612873576233360455520117731076644695933073121", "237857322216070326038939055851122466647816876891436053757510012155498138055", "1"}
	pi_b := [3][2]string{{"8039359843367091011417471503693823059611953364550795770136412617762570717893", "20362901353774374429136975997971776017368444706113308359030103452844198886346"}, {"9380799065296203957622237045504323238444864906244709911476053545378223821591", "15835626974966355394858479666599410188851399767401275315818708596794329405031"}, {"1", "0"}}
	pi_c := [3]string{"4044956268116702752876097991134769141268945862619734431496009981617907607919", "13906055398350259644927757594138716667642003272757689364098168942359273563277", "1"}

	want := Proof{
		Pi_a:     pi_a,
		Pi_b:     pi_b,
		Pi_c:     pi_c,
		Protocol: "groth16",
		Curve:    "bn128",
	}
	if !reflect.DeepEqual(got, want) {
		t.Error("Proof parsing failed. Objects are not equal")
	}
}

func TestPackToSolidityProof(t *testing.T) {
	strPublicSignals := `["16000534653676138996713327308904050705310694920288652176050461465752592825931","8645855190507523104841700339788733779121603968888715024493408324017192995125","1241684909991387711750284969837868400833048828403","10000000000000000000","1","1"]`
	got, err := ParseSixPublicSignals(strPublicSignals)
	if err != nil {
		t.Error("Unable to parse ", err)
	}

	want := SixPublicSignals{"16000534653676138996713327308904050705310694920288652176050461465752592825931", "8645855190507523104841700339788733779121603968888715024493408324017192995125", "1241684909991387711750284969837868400833048828403", "10000000000000000000", "1", "1"}

	if !reflect.DeepEqual(got, want) {
		t.Error("Public Signals parsing failed")
	}
}

func TestToNoteHexConversion(t *testing.T) {
	start := "16000534653676138996713327308904050705310694920288652176050461465752592825931"

	got, err := ToNoteHex(start)
	if err != nil {
		t.Error("Unable to convert string ", err)
	}

	want := "0x235ffb4f845bec7dcb1fffbd82391cecbc278bca9187fbcd7cddf854fed5be4b"

	if got != want {
		t.Error("Unable to convert big int to hex string")
	}
}
